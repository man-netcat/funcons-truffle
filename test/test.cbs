### TestFile

[
  Funcon   left-to-right   Alias l-to-r
  Funcon   right-to-left   Alias r-to-l
  Funcon   sequential      Alias seq
  Funcon   effect
  Funcon   choice
  Funcon   if-true-else    Alias if-else
  Funcon   while-true      Alias while
  Funcon   do-while-true   Alias do-while
  Funcon   interleave
  Datatype yielding
  Funcon   signal
  Funcon   yielded
  Funcon   yield
  Funcon   yield-on-value
  Funcon   yield-on-abrupt
  Funcon   atomic
]

Meta-variables
  T <: values
  T* <: values*

#### TestSection

Funcon
  print(_:values*) : =>null-type
/*
  `print(X*)` evaluates the arguments `X*` and emits the resulting sequence of
  values on the standard-out channel. `print( )` has no effect.
*/
Rule
  print(V*:values*) -- standard-out!(V*) -> null-value

Funcon
  choice(_:(=>T)+) : =>T
/*
  `choice(Y, ...)` selects one of its arguments, then computes it.
  It is associative and commutative.
*/
Rule
  choice(X*, Y, Z*) ~> Y

Funcon
  if-true-else(_:booleans, _:=>T, _:=>T) : =>T
Alias
  if-else = if-true-else
/*
  `if-true-else(B, X, Y)` evaluates `B` to a Boolean value, then reduces
  to `X` or `Y`, depending on the value of `B`.
*/
Rule
  if-true-else(true, X, Y) ~> X
Rule
  if-true-else(false, X, Y) ~> Y

Funcon
  left-to-right(_:(=>(T)*)*) : =>(T)*
Alias
  l-to-r = left-to-right
/*
  `left-to-right(...)` computes its arguments sequentially, from left to right,
  and gives the resulting sequence of values, provided all terminate normally.
  For example, `integer-add(X, Y)` may interleave the computations of `X` and
  `Y`, whereas `integer-add left-to-right(X, Y)` always computes `X` before `Y`.

  When each argument of `left-to-right(...)` computes a single value, the type
  of the result is the same as that of the argument sequence. For instance,
  when `X:T` and `Y:T'`, the result of `left-to-right(X, Y)` is of type `(T, T')`.
  The only effect of wrapping an argument sequence in `left-to-right(...)` is to
  ensure that when the arguments are to be evaluated, it is done in the
  specified order.
*/
Rule
                              Y ---> Y'
  ------------------------------------------------------------
  left-to-right(V*:(T)*, Y, Z*) ---> left-to-right(V*, Y', Z*)
Rule
  left-to-right(V*:(T)*) ~> V*
